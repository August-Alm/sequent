
Type+ A+,B+ ::= X+ | A+ ⊕ B+ | A+ ⊗ B+ | ∃Xs.A+ | ⊖A− | ↑A−

Type− A−,B− ::= X− | A− & B− | A− `& B− | ∀Xs.A− | ¬A+ | ↓A+

The + type-formers are all data, and the - type-formers are all
codata! Here

data ⊖A where
  (_): ⊢ ⊖A | A    ---    (k: cns A): cns ⊖A

code ¬A where
  [_]: A | ¬A ⊢    ---    [x: prd A]: prd ¬A

data ↑A where
  close: A ⊢ ↑A |    ---    close(x: prd A): prd ↑A 

code ↓A where
  thunk: | ↓A ⊢ A    ---    thunk(k: cns A): cns ↓A

We also have, fundamentally,

code (X:+) → (Y:−) :− where
  ·: (X:+ |X → Y ⊢ Y:−)


-- Primitives
codata Forall(F) { insta: {A} Forall(F) -> F(A) }
codata Fun(A, B) { apply: Fun(A, B) -> A -> B }
data Box(E: ext) { mk(ext E) }

-- Compilation of:  id : ∀A. A → A
def id(k: cns Forall(λA. Fun(A, A))) =
  ⟨cocase { insta{A} => cocase { apply(x, u) => forward x u }} | k⟩

-- Compilation of:  idInt : Int → Int  
def idInt(x: prd Box(I32), k: cns Box(I32)) =
  switch x { box(x') => invoke k box(x') }

-- Both have same runtime behavior on strict arguments

  ⟨C(Γ) | µ˜x.s ⟩                    → let_prd v = m(Γ); s
  ⟨x | case {C(Γ) ⇒ s, ... }⟩        → switch_prd v {m(Γ) ⇒ s, ...}
  ⟨µα.s | case {C(Γ) ⇒ s, ... }⟩     → new_cns v = {m(Γ) ⇒ s, ...}; s
  ⟨C(Γ) | α⟩                         → invoke_cns v m(Γ)
  
  ⟨µα.s |D(Γ)⟩                       → let_cns v = m(Γ); s
  ⟨cocase {D(Γ) ⇒ s, ... } | α⟩      → switch_cns v {m(Γ) ⇒ s, ...}
  ⟨cocase {D(Γ) ⇒ s, ... } | µ˜x.s⟩  → new_prd v = {m(Γ) ⇒ s, ...}; s
  ⟨x | D(Γ)⟩                         → invoke_prd v m(Γ)

  [A → B] = ↑([A] → ↓[B])

  [fun (x: A) ⇒ t] = 
    close(cocase {apply(x, k) ⇒ 
      ⟨cocase {thunk(k') ⇒ ⟨[t] | k'⟩} | k⟩ 
    })