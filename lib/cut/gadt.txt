## Typing Rules for Cut with Higher-Kinded Types and GADTs

This document extends the typing rules from description.txt to support the richer
type system defined in Cut.Types, including:
- Higher-kinded types and type application
- Polymorphic methods with quantification
- GADTs with type constraints
- Full type inference and checking

The key difference from the simple system: signatures are now parametric with
kinds, methods have quantified type variables, and types can be applications.

### Notation

We extend the notation from description.txt:

**Kinds:**
  κ ::= type | κ → κ

**Types:**
  τ ::= α                           (type variable)
      | τ(τ)                        (type application)
      | T                           (signature reference)
      | prd τ | cns τ | ext τ       (chirality types)

**Type Environments:**
  Δ ::= α : κ, ...                  (type variable environment)
  Γ ::= v : τ, ...                  (term variable environment)

**Signatures:**
  Σ ::= signature T : κ = {m₁, ..., mₖ}, ...

**Methods (in signatures):**
  m ::= symbol : ∀β₁:κ₁, ..., βₘ:κₘ. Γ : τ where C

Where:
  - Γ is a type environment (v₁ : τ₁, ..., vₙ : τₙ) where each τᵢ is a polarized type
  - τ is the polarized result type (prd T, cns T, or ext T)
  - C is a list of type equality constraints (for GADTs)
  - The polarity of τ determines if this is a constructor (prd) or destructor (cns)

**Label Environment:**
  Θ ::= l : Γ, ...

**Type equality constraints:**
  C ::= [α = τ, ...]

### Judgments

We use several judgment forms:

  Δ ⊢ τ : κ                        (type τ has kind κ)
  Δ ⊢ τ₁ ≡ τ₂ : κ                  (types are equal at kind κ)
  Δ ⊢ C                            (constraints C are satisfied)
  Σ; Δ; Θ; Γ ⊢ s                   (statement s is well-typed)
  Σ; Δ ⊢ Θ                         (label environment is well-formed)
  Σ Θ ⊢ P                          (program P is well-typed)

### Kinding Rules

Type variables have their kinds from the type environment:

  α : κ ∈ Δ
  --------- [K-VAR]
  Δ ⊢ α : κ

Signatures have kinds determined by their parameters:

  signature T(α₁ : κ₁, ..., αₙ : κₙ) ∈ Σ
  --------------------------------------- [K-SIG]
  Δ ⊢ T : κ₁ → ... → κₙ → type

Type application applies a constructor to an argument:

  Δ ⊢ τ₁ : κ → κ'    Δ ⊢ τ₂ : κ
  -------------------------------- [K-APP]
  Δ ⊢ τ₁(τ₂) : κ'

Chirality types are always proper types:

  Δ ⊢ τ : type
  ---------------- [K-PRD]
  Δ ⊢ prd τ : type

  Δ ⊢ τ : type
  ---------------- [K-CNS]
  Δ ⊢ cns τ : type

  Δ ⊢ τ : type
  ---------------- [K-EXT]
  Δ ⊢ ext τ : type

Primitive types have their annotated kinds:

  prim P : κ
  ---------- [K-PRIM]
  Δ ⊢ P : κ

### Type Equality

Reflexivity, symmetry, and transitivity:

  Δ ⊢ τ : κ
  ------------- [EQ-REFL]
  Δ ⊢ τ ≡ τ : κ

  Δ ⊢ τ₂ ≡ τ₁ : κ
  ---------------- [EQ-SYM]
  Δ ⊢ τ₁ ≡ τ₂ : κ

  Δ ⊢ τ₁ ≡ τ₂ : κ    Δ ⊢ τ₂ ≡ τ₃ : κ
  ----------------------------------- [EQ-TRANS]
  Δ ⊢ τ₁ ≡ τ₃ : κ

Congruence for type application:

  Δ ⊢ τ₁ ≡ τ₁' : κ → κ'    Δ ⊢ τ₂ ≡ τ₂' : κ
  ------------------------------------------- [EQ-APP]
  Δ ⊢ τ₁(τ₂) ≡ τ₁'(τ₂') : κ'

Constraints provide equations:

  (α = τ) ∈ C    Δ ⊢ C    Δ ⊢ τ : κ    α : κ ∈ Δ
  ------------------------------------------------ [EQ-CONSTR]
  Δ ⊢ α ≡ τ : κ

### Constraint Satisfaction

Empty constraints are satisfied:

  -------- [C-EMPTY]
  Δ ⊢ []

Constraints extend with equations:

  Δ ⊢ C    Δ ⊢ τ₁ ≡ τ₂ : κ    α : κ ∈ Δ
  ---------------------------------------- [C-CONS]
  Δ ⊢ [(α = τ₁), ...C] when α = τ₂

### Type Environment Lookup

Variables have their types from the environment:

  (v : τ) ∈ Γ
  ----------- [ENV-LOOKUP]
  Γ(v) = τ

Type environment concatenation (Γ₁, Γ₂) adds Γ₂ to the right (head) of Γ₁.

Type environment extension Γ, v : τ adds v : τ to the head of Γ.

### Statement Typing Rules

The key insight: methods are polymorphic, so we must instantiate their quantified
type variables when using them. We write θ for a type substitution that instantiates
quantified variables.

---

**[PROGRAM]** - Programs are collections of labeled definitions

  Σ; ∅ ⊢ Θ    Θ(l) = Γ    Σ; ∅; Θ; Γ ⊢ s    (for each label l)
  ---------------------------------------------------------------
  Σ Θ ⊢ define l₁ : Γ₁ = s₁, ..., lₙ : Γₙ = sₙ

Programs are typed in the empty type variable environment (∅) since they must be
closed. Each label's statement must type check in its declared environment.

---

**[JUMP]** - Jumping to a label requires exact environment match

  Θ(l) = Γ
  ----------
  Γ ⊢ jump l

This rule is unchanged. The environment must exactly match the label's signature.

---

**[SUBSTITUTE]** - Explicit substitutions reorder/duplicate/erase variables

  Γ'(v'ᵢ) = τᵢ    Γ(vᵢ) = τᵢ    (for each i)    Γ' ⊢ s
  -------------------------------------------------------
  Γ ⊢ substitute [v'₁ → v₁, ..., v'ₙ → vₙ]; s

This rule is unchanged. Each substitution pair must preserve types, and the body
must type check in the reordered environment.

---

**[EXTERN]** - External operations with multiple continuations

  extern m : (τ₁, ..., τₙ) ⇒ [(Γ₁), ..., (Γₖ)]    (signature of extern)
  Γ(vᵢ) = τᵢ    (for each argument i)
  Γ, Γⱼ ⊢ sⱼ    (for each clause j)
  --------------------------------------------------
  Γ ⊢ extern m(v₁, ..., vₙ){(Γ₁) ⇒ s₁, ..., (Γₖ) ⇒ sₖ}

This rule is unchanged. External operations are typed separately and their
signatures specify argument types and continuation environments.

---

**[LET]** - Binding a producer (data constructor or let-bound producer)

  signature T : κ = {..., m : ∀β̄:κ̄'. Γ : prd τᵣ where C, ...} ∈ Σ
  
  θ = [ᾱ ↦ τ̄, β̄ ↦ σ̄]    (type substitution instantiating parameters and quantifiers)
  
  ᾱ : κ̄, β̄ : κ̄' ⊢ C    (constraints in signature must be satisfiable)
  
  Γ' = θ(Γ)    (method's environment, instantiated)
  
  τ_v = θ(prd τᵣ)    (the bound variable's type)
  
  Δ ⊢ τ_v : type    (result type is well-kinded)
  
  Σ; Δ; Θ; Γ_ctx, v : τ_v ⊢ s    (continuation with bound variable)
  ---------------------------------------------------------------
  Σ; Δ; Θ; Γ_ctx, Γ' ⊢ let v = m[σ̄](Γ'); s

**Intuition:** Let binds a producer value. The method m may be polymorphic (∀β̄),
so we must provide type arguments to instantiate it. The pattern arguments Γ'
are consumed from the environment. The result type (after substitution) becomes
the type of the bound producer variable v.

**Note:** When T has no type parameters and m has no quantified variables and C 
is empty, this reduces to the simpler form.

---

**[NEW]** - Binding a consumer (codata destructor or new-bound consumer)

  signature T : κ = {m₁, ..., mₖ} ∈ Σ
  
  For each method mᵢ : ∀β̄ᵢ:κ̄ᵢ. Γᵢ : cns τᵣᵢ where Cᵢ:
  
    θᵢ = [ᾱ ↦ τ̄, β̄ᵢ ↦ σ̄ᵢ]    (instantiation for this method)
    
    ᾱ : κ̄, β̄ᵢ : κ̄ᵢ ⊢ Cᵢ    (constraints must be satisfiable)
    
    Γᵢ' = θᵢ(Γᵢ)    (instantiated method environment)
    
    Σ; Δ; Θ; Γᵢ', Γ₀ ⊢ sᵢ    (each branch types with its arguments + closure)
  
  τ_v = cns (T[τ̄])    (the bound consumer has the instantiated signature type)
  
  Δ ⊢ τ_v : type
  
  Σ; Δ; Θ; Γ_ctx, v : τ_v ⊢ s    (continuation with bound consumer)
  ---------------------------------------------------------------
  Σ; Δ; Θ; Γ_ctx, Γ₀ ⊢ new v : T[τ̄] = (Γ₀){m₁[σ̄₁](Γ₁') ⇒ s₁, ..., mₖ[σ̄ₖ](Γₖ') ⇒ sₖ}; s

**Intuition:** New binds a consumer value by creating a cocase with branches for
all methods in the signature. The closure environment Γ₀ is captured and available
in each branch. Each method's environment Γᵢ contains all its arguments (with
polarized types indicating whether they're producers, consumers, or external values).

---

**[SWITCH]** - Pattern matching on a producer

  signature T : κ = {m₁, ..., mₖ} ∈ Σ
  
  Γ_ctx(v) = prd (T[τ̄])    (switching on a producer of instantiated signature type)
  
  For each method mᵢ : ∀β̄ᵢ:κ̄ᵢ. Γᵢ : prd τᵣᵢ where Cᵢ:
  
    θᵢ = [ᾱ ↦ τ̄, β̄ᵢ ↦ σ̄ᵢ]    (must instantiate signature parameters consistently)
    
    ᾱ : κ̄, β̄ᵢ : κ̄ᵢ ⊢ Cᵢ    (constraints satisfied)
    
    ᾱ : κ̄, β̄ᵢ : κ̄ᵢ ⊢ θᵢ(prd τᵣᵢ) ≡ prd (T[τ̄]) : type    (result type matches)
    
    Γᵢ' = θᵢ(Γᵢ)    (instantiated method environment)
    
    Σ; Δ; Θ; Γ_ctx, Γᵢ' ⊢ sᵢ    (each branch has method's arguments available)
  ---------------------------------------------------------------
  Σ; Δ; Θ; Γ_ctx, v : prd (T[τ̄]) ⊢ switch v {m₁[σ̄₁](Γ₁') ⇒ s₁, ..., mₖ[σ̄ₖ](Γₖ') ⇒ sₖ}

**Intuition:** Switch pattern matches on a producer value. The branches must cover
all methods in the signature. Each method's arguments become available in the
corresponding branch. The signature is instantiated at the type arguments of v.

**Key for GADTs:** The result type τᵣᵢ (after instantiation) must equal T[τ̄].
For non-GADT constructors this is automatic, but for GADT constructors this
provides type refinement - the constraints Cᵢ may refine the type parameters
based on which constructor matched.

---

**[INVOKE]** - Invoking a method on a consumer

  signature T : κ = {..., m : ∀β̄:κ̄'. Γ : cns τᵣ where C, ...} ∈ Σ
  
  Γ_ctx(v) = cns (T[τ̄])    (invoking method on consumer of instantiated type)
  
  θ = [ᾱ ↦ τ̄, β̄ ↦ σ̄]    (instantiate signature parameters and method quantifiers)
  
  ᾱ : κ̄, β̄ : κ̄' ⊢ C    (constraints satisfied)
  
  ᾱ : κ̄, β̄ : κ̄' ⊢ θ(cns τᵣ) ≡ cns (T[τ̄]) : type    (result type matches)
  
  Γ' = θ(Γ)    (instantiated method environment)
  
  Γ_ctx = (Γ', v : cns (T[τ̄]))    (environment must match exactly)
  ---------------------------------------------------------------
  Σ; Δ; Θ; Γ', v : cns (T[τ̄]) ⊢ invoke v m[σ̄](Γ')

**Intuition:** Invoke calls a method on a consumer. The method may be polymorphic,
so we instantiate its quantified variables. The environment must contain exactly
the method's arguments (with polarized types) plus the consumer being invoked.

**Key for GADTs:** The result type must match the consumer's type after applying
constraints, enabling type refinement based on which method is being invoked.

---

### Type Inference Strategy

For type checking with polymorphism and GADTs:

1. **Signature lookup**: Given method symbol m, find parent signature T(ᾱ : κ̄)
   
2. **Parameter inference**: At usage site, infer or check type arguments τ̄
   - For let: τ̄ comes from result type unification
   - For switch: τ̄ comes from scrutinee type
   - For invoke: τ̄ comes from consumer type
   
3. **Quantifier instantiation**: For method's ∀β̄:κ̄', generate fresh unification
   variables or infer from context
   
4. **Constraint solving**: Check that constraints C are satisfiable under the
   instantiation θ = [ᾱ ↦ τ̄, β̄ ↦ σ̄]
   
5. **Type checking**: Apply θ to method's signature and check that:
   - Argument environments match
   - Result type matches expected type
   - All types are well-kinded

### Examples

**Example 1: Non-GADT data type (List)**

Signature:
```
signature List : type -> type = {
  nil  : ∀a:type. () : prd List(a)
  cons : ∀a:type. (x : prd a, xs : prd List(a)) : prd List(a)
}
```

Typing a switch:
```
Γ_ctx, xs : prd List(Nat) ⊢ 
  switch xs {
    nil[Nat]() ⇒ ...
    cons[Nat](y : prd Nat, ys : prd List(Nat)) ⇒ ...
  }
```

Both branches instantiate a to Nat, matching xs's type.

---

**Example 2: GADT (Length-indexed vectors)**

Signature:
```
signature Vec : type -> Nat -> type = {
  vnil  : ∀a:type. () : prd Vec(a, Zero) 
         where []
         
  vcons : ∀a:type, m:Nat. (x : prd a, xs : prd Vec(a,m)) : prd Vec(a, Succ(m))
         where []
}
```

Typing a switch with refinement:
```
Γ_ctx, v : prd Vec(Int, n) ⊢
  switch v {
    vnil[Int]() ⇒ 
      (* Here we know n ≡ Zero *)
      ...
    vcons[Int, m](x : prd Int, xs : prd Vec(Int, m)) ⇒
      (* Here we know n ≡ Succ(m) *)
      ...
  }
```

The result types refine n: in the nil branch, n must be Zero; in the cons
branch, n must be Succ(m) for some m.

---

**Example 3: Polymorphic codata (Stream)**

Signature:
```
signature Stream : type -> type = {
  head : ∀a:type. (s : prd Stream(a), k : cns a) : cns Stream(a)
  tail : ∀a:type. (s : prd Stream(a), k : cns Stream(a)) : cns Stream(a)
}
```

Creating a stream:
```
Γ_ctx ⊢ new s : Stream(Nat) = (){
      head[Nat](s : prd Stream(Nat), k : cns Nat) ⇒ ...
      tail[Nat](s : prd Stream(Nat), k : cns Stream(Nat)) ⇒ ...
    }; ...
```

Here s : cns Stream(Nat). Each method's type is instantiated with a ↦ Nat.

