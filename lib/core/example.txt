let a = 9 in
let f = fun (x: Int) => a + x in
let y = 1 in
f y

translate to

signature Cont = { ret(ext Int) }
signature Func = { app(cns Cont, ext Int) }

extern lit_9() {
  (a: ext Int) => {
    new f = (a: ext Int){
      app(k, x) => {
        extern add(a, x) {
          (b: ext Int) => {
            substitute [k → k, b → b];
            invoke k ret           // ← no (b)
          }
        }
      }
    };
    new k = (){
      ret(r) => { extern return(r) {} }
    };
    extern lit_1() {
      (y: ext Int) => {
        substitute [f → f, k → k, y → y];
        invoke f app              // ← no (k, y), and 'app' not 'apply'
      }
    }
  }
}


General Lambda Compilation Strategy
From the example, we can extract this pattern:

Source
fun (x₁: τ₁, ..., xₙ: τₙ) => body

where a₁, ..., aₘ are the free variables of the lambda.

Target (Cut)
new f = (a₁: τ'₁, ..., aₘ: τ'ₘ){
  app(k: cns Cont⟦return_type⟧, x₁: τ'₁, ..., xₙ: τ'ₙ) => {
    ⟦body⟧ₖ    // body compiled in CPS, with continuation k
  }
};
...

Key principles:
Aspect --	Translation
Lambda --	new statement (creates a consumer value)
Free variables	-- Closure environment (a₁, ..., aₘ)
Parameters --	Method parameters in app(k, x₁, ..., xₙ)
Return --	Extra continuation parameter k: cns Cont
Function call	-- invoke f app after arranging env to [f, k, args...]

The Func signature pattern:
For a function τ₁ → ... → τₙ → τᵣ:
signature Func = { app(cns Cont⟦τᵣ⟧, τ'₁, ..., τ'ₙ) }
signature Cont⟦τᵣ⟧ = { ret(τ'ᵣ) }

Application compilation:
Source: f y

Target:
substitute [f → f, k → k, y → y];   // arrange env to match app(cns Cont, ext Int)
invoke f app

==========

code Stream: type -> type where
  { head: {a} Stream(a) -> a
  ; tail: {a} Stream(a) -> Stream(a)
  }

let const_stream(x: Int): Stream(Int) = 
  new Stream(a)
  { head{_} => x
  ; tail{_} => const_stream(x)
  }

translate to

signature ContInt = { ret(ext Int) }
signature ContStream = { ret(cns Stream) }
signature Stream = { head(cns ContInt), tail(cns ContStream) }

define const_stream: k: cns ContStream, x: ext Int =
  new stream = (x: ext Int){
    head(k_h) => {
      substitute [k_h → k_h, x → x];
      invoke k_h ret
    }
    tail(k_t) => {
      substitute [k_t → k_t, x → x];
      jump const_stream
    }
  };
  substitute [k → k, stream → stream];
  invoke k ret

================

## General codata compilation pattern

Source codata definition
code T: ... -> type where
  { m₁: T(...) -> τ₁₁ -> ... -> τ₁ₖ -> r₁
  ; m₂: T(...) -> τ₂₁ -> ... -> τ₂ⱼ -> r₂
  ; ...
  }

Target Cut signatures
signature Cont⟦r₁⟧ = { ret(⟦r₁⟧) }
signature Cont⟦r₂⟧ = { ret(⟦r₂⟧) }
...

signature T = { 
  m₁(cns Cont⟦r₁⟧, ⟦τ₁₁⟧, ..., ⟦τ₁ₖ⟧),
  m₂(cns Cont⟦r₂⟧, ⟦τ₂₁⟧, ..., ⟦τ₂ⱼ⟧),
  ...
}

The transformation rules

Source	Cut
Codata type T	-- Signature T with values as cns T
Method m: T -> args... -> r	-- m(cns Cont⟦r⟧, args...) in signature
Return type r	-- Continuation signature Cont⟦r⟧ = { ret(⟦r⟧) }
Copattern match new T { m₁ => e₁; ... }	-- new v = (fvs){ m₁(k, params) => ⟦e₁⟧ₖ; ... }
Method call t.m(args...)	-- Create continuation, arrange env, invoke t m

The key insight
Every codata method gets CPS-transformed: the return type r becomes an extra first parameter k: cns Cont⟦r⟧, and the body must eventually invoke k ret to return its result.

This is why Fun(a)(b) with method apply: Fun(a)(b) -> a -> b becomes:
signature Cont⟦b⟧ = { ret(⟦b⟧) }
signature Fun = { app(cns Cont⟦b⟧, ⟦a⟧) }


The trick is double-negation/CPS-transform

In Core:
stream(Int) is a codata type
α : cns stream(Int) directly consumes the stream

In Cut:
* Stream values are cns Stream (consumers that respond to head/tail)
* But what is a consumer-of-a-consumer?
The trick: wrap in a Cont type!

Core	-- Cut
codata type T	-- signature T, values are cns T
cns T (consumer of codata)	-- cns Cont⟦T⟧ where Cont⟦T⟧ = { ret(cns T) }

General translation of ⟨cocase {D(Γ) ⇒ s, ...} | α⟩
Where α : cns T in Core and T is codata:
new v = (fvs){
  D₁(params) => ⟦s₁⟧
  D₂(params) => ⟦s₂⟧
  ...
};
substitute [..., α → α, v → v];
invoke α ret                      // pass codata value to continuation!

The continuation α in Cut has type cns Cont⟦T⟧, and we invoke α ret to deliver the codata value v : cns T.

The polarities work out.
α : cns Cont⟦T⟧    where Cont⟦T⟧ = { ret(cns T) }
v : cns T

invoke α ret   // α consumed, env must have [cns T], which v provides ✓

So the "Cont-types trick" is: every consumer of codata in Core becomes a consumer of a continuation-over-codata in Cut. This is how CPS "wraps" the direct interaction into explicit continuation passing.

⟨cocase { D₁(Γ) ⇒ s₁, ... } | α⟩ ⟹
new v = (...){ D₁(params) => ⟦s₁⟧; ... };
substitute [..., α → α, v → v];
invoke α ret

⟨μα.s | D(args)⟩ ⟹
new α = (args){
  ret(v) => substitute [...]; invoke v D
};
⟦s⟧

=======
Translate types:
⟦cns T⟧ = cns Cont⟦T⟧    when T is codata
⟦cns T⟧ = cns T          when T is data
⟦prd T⟧ = prd T          always
⟦ext T⟧ = ext T          always

Why this works
In Core, cns T where T is codata means "a continuation that will receive a codata value".

In Cut:

The codata value itself has type cns T (responds to methods)
The continuation that receives it has type cns Cont⟦T⟧
These are different things that share type cns T in Core but are distinguished in Cut.

Implementation approach
During Core → Cut translation, maintain:

A map of which type symbols are codata
Translate every variable binding's type using the rule above

Then when creating a codata value via new, the value has the "inner" type cns T, and you deliver it to the translated continuation via invoke k ret.

The invariant
Every codata value in Cut is immediately delivered to a continuation — it never gets bound to a variable of type cns T directly. Variable bindings of "codata consumer type" always go through Cont⟦T⟧.