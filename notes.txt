```ocaml
data nat: type where
  { zero: nat
  ; succ: nat -> nat -> nat
  }

let is_even(n: nat): nat = 
  match n with
  { zero => true
  ; succ(m) => is_odd(m)
  }

let is_odd(n: nat): nat =
  match n with
  { zero => false
  ; succ(m) => is_even(m)
  }
```

A toplevel `let foo((xi : ti)'s) = t` should convert to a toplevel
`def foo((xi: Prd (convert ti))'s)(ùõº: Cns bool) = ‚ü®convert t | ùõº ‚ü©`.
That is, the function gets an additional fresh consumer (co)variable
as argument, and returns the statement formed by pairing it the the
producer that arises as the conversion of the original function body.
Thus, conversion of the above definitions should result in (omitting
the converted types):

```
def is_even(n: Prd nat)(ùõº: Cns bool) =
 ‚ü® Œºx.‚ü®n | case {
        zero(x) => ‚ü®true() | x‚ü©
        succ(m)(x) => ‚ü®Œºy.‚ü®is_odd | $app{nat, bool}(y, ŒºÃÉy.‚ü®m | y‚ü©)‚ü© | x‚ü©
      }‚ü©
  | ùõº ‚ü©

def is_odd(n: Prd nat)(ùõº: Cns bool) =
  ‚ü® Œºx.‚ü®n | case {
        zero(x) => ‚ü®false() | x‚ü©
        succ(m)(x) => ‚ü®Œºy.‚ü®is_even | $app{nat, bool}(y, ŒºÃÉy.‚ü®m | y‚ü©)‚ü© | x‚ü©
      }‚ü©
  | ùõº ‚ü©
```

However, there is a problem here. In the body of is_even, is_odd is
a mere producer variable, and vice versa. We should probably add a
constructor `| Call of Path.t * (producer list) * (consumer list)`
of the `statement` type, to handle calls of top-level functions.

  const_stream(x: nat)(u$63: cns stream(nat)): stream(nat) =
    ‚ü®new {
      head{_}(self)(u$64) => ‚ü®x | u$64‚ü©
      tail{_}(self)(u$65) => ‚ü®self | u$65‚ü©
    } | u$63‚ü©

    This is incorrect, I think. In Core both head and tail should have a single continutation/consumer argument. An explicit invocation

    head{a}(z) in Lang

    becomes

    Œºk.< conv z | dtor{converted_ty_args}(k) >

    If z is a stream constructed as new { tail{_}(self) => x ; head{_}(self) => self } in Lang, we have
    
    conv z = new { tail{_}(k) => <x|k>; head{}(k)
     we then evaluate
    the cut by proceeding with the statement sh,