```ocaml
data nat: type where
  { zero: nat
  ; succ: nat -> nat -> nat
  }

let is_even(n: nat): nat = 
  match n with
  { zero => true
  ; succ(m) => is_odd(m)
  }

let is_odd(n: nat): nat =
  match n with
  { zero => false
  ; succ(m) => is_even(m)
  }
```

A toplevel `let foo((xi : ti)'s) = t` should convert to a toplevel
`def foo((xi: Prd (convert ti))'s)(ùõº: Cns bool) = ‚ü®convert t | ùõº ‚ü©`.
That is, the function gets an additional fresh consumer (co)variable
as argument, and returns the statement formed by pairing it the the
producer that arises as the conversion of the original function body.
Thus, conversion of the above definitions should result in (omitting
the converted types):

```
def is_even(n: Prd nat)(ùõº: Cns bool) =
 ‚ü® Œºx.‚ü®n | case {
        zero(x) => ‚ü®true() | x‚ü©
        succ(m)(x) => ‚ü®Œºy.‚ü®is_odd | $app{nat, bool}(y, ŒºÃÉy.‚ü®m | y‚ü©)‚ü© | x‚ü©
      }‚ü©
  | ùõº ‚ü©

def is_odd(n: Prd nat)(ùõº: Cns bool) =
  ‚ü® Œºx.‚ü®n | case {
        zero(x) => ‚ü®false() | x‚ü©
        succ(m)(x) => ‚ü®Œºy.‚ü®is_even | $app{nat, bool}(y, ŒºÃÉy.‚ü®m | y‚ü©)‚ü© | x‚ü©
      }‚ü©
  | ùõº ‚ü©
```

However, there is a problem here. In the body of is_even, is_odd is
a mere producer variable, and vice versa. We should probably add a
constructor `| Call of Path.t * (producer list) * (consumer list)`
of the `statement` type, to handle calls of top-level functions.

  const_stream(x: nat)(u$63: cns stream(nat)): stream(nat) =
    ‚ü®new {
      head{_}(self)(u$64) => ‚ü®x | u$64‚ü©
      tail{_}(self)(u$65) => ‚ü®self | u$65‚ü©
    } | u$63‚ü©

    This is incorrect, I think. In Core both head and tail should have a single continutation/consumer argument. An explicit invocation

    head{a}(z) in Lang

    becomes

    Œºk.< conv z | dtor{converted_ty_args}(k) >

    If z is a stream constructed as new { tail{_}(self) => x ; head{_}(self) => self } in Lang, we have
    
    conv z = new { tail{_}(k) => <x|k>; head{}(k)
     we then evaluate
    the cut by proceeding with the statement sh,


(**
  Module: Cut.Terms
  Description: Term syntax of the intermediate language Cut.
  
  This module defines the abstract syntax of the
  intermediate language Cut.
*)

open Common.Identifiers

type symbol = Path.t

type variable = Ident.t 

type label = MkLabel of Path.t

type typ =
  | Prd of symbol
  | Cns of symbol
  | Ext of symbol

type typ_env = (variable * typ) list

type label_env = (label * typ_env) list

type signature_env = (symbol * (symbol * typ_env) list) list

type import_env = (symbol * (typ list * (typ list) list)) list

type statement =
  | Jump of label
  | Substitute of ((variable * variable) list) * statement
  | Let of variable * symbol * (variable list) * statement
  | New of variable * symbol * (variable list) * branches * statement
  | Switch of variable * branches
  | Invoke of variable * symbol
  | Extern of symbol * variable list * (((variable list) * statement) list)

and branches = (symbol * (variable list) * statement) list

module Label = struct
  let to_string (MkLabel l) = Path.name l
end

module Symbol = struct
  let to_string = Path.name
end

type typed_statement = MkTyped of (typ_env * typed_node)

and clauses = (symbol * variable list * typed_statement) list

and typed_node =
  | Jump of label
  | Substitute of ((variable * variable) list) * typed_statement
  | Let of variable * symbol * (variable list) * typed_statement
  | New of variable * symbol * (variable list) * clauses * typed_statement
  | Switch of variable * clauses
  | Invoke of variable * symbol
  | Extern of symbol * variable list * (((variable list) * typed_statement) list)

module Check = struct

  exception Error of string
  let error s = raise (Error s)

  (** Looks up the type of a variable in the type environment *)
  let get_type (v: variable) (gamma: typ_env) =
    match List.assoc_opt v gamma with
    | Some t -> t
    | None -> error ("unknown variable: " ^ Ident.name v)

  (** Looks up the type environment associated with a label *)
  let get_type_env (l: label) (theta: label_env) =
    match List.assoc_opt l theta with
    | Some g -> g
    | None -> error ("unknown label: " ^ (Label.to_string l))

  (** Looks up the signature associated with a type symbol *)
  let get_signature (tty: symbol) (sigma: signature_env) =
    match List.assoc_opt tty sigma with
    | Some mg -> mg
    | None -> error ("unknown type symbol: " ^ (Symbol.to_string tty))

  (** Looks up the declaration associated with a constructor (method): its
      declaring type and the declared typing of its arguments. *)
  let get_declaration (ctor: symbol) (sigma: signature_env) =
    sigma
    |> List.find_opt (fun (_, mg) -> List.exists (fun (m, _) -> m = ctor) mg)
    |> function
      | Some (t, mg) -> (t, snd (List.find (fun (m, _) -> m = ctor) mg))
      | None -> error ("no matching signature for method: " ^ (Symbol.to_string ctor))

  (** Gets the interface of the imported term. *)
  let get_interface (ext: symbol) (iota: import_env) =
    match List.assoc_opt ext iota with
    | Some (ins, outs) -> (ins, outs)
    | None -> error ("unknown external: " ^ (Symbol.to_string ext))

  (** Skips the initial part of a type environment g that matches vs,
      returning the matching and remaining part of g. Raises an error
      if vs is not a prefix of g. *)
  let skip (vs: variable list) (g: typ_env) =
    let rec loop vs g0 g1 =
      match vs, g1 with
      | [], g1 -> (List.rev g0), g1
      | v :: vs, (v', t) :: g1 when v = v' -> loop vs ((v', t) :: g0) g1
      | _ -> error "type environment mismatch in let"
    in loop vs [] g
  
  let arguments (expected: typ_env) (vs: variable list) (gamma: typ_env) =
    let given = List.map (fun v -> (v, get_type v gamma)) vs in
    if List.length expected <> List.length given then
      error "argument length mismatch";
    List.iter2
      (fun (v1, t1) (v2, t2) ->
        if v1 <> v2 then error "argument name mismatch";
        if t1 <> t2 then error "argument type mismatch")
      expected given
  
  let symbols (expected: symbol) (given: symbol) =
    if expected <> given then error "symbol mismatch"
  
  let rec statement
      (sigma: signature_env) (theta: label_env) (iota: import_env) (gamma: typ_env)
      (s: statement) =
    match s with
    | Jump l ->
      let g = get_type_env l theta in
      if gamma <> g then error "type environment mismatch in jump"
      else MkTyped (g, Jump l)
    
    | Substitute (subs, s) ->
      let g = List.map (fun (v', v) -> (v', get_type v gamma)) subs in
      let st = statement sigma theta iota g s in
      MkTyped (gamma, Substitute (subs, st))
    
    | Let (v, m, vs, s) ->
      let g0, g1 = skip vs gamma in
      let (m_ty, m_g) = get_declaration m sigma in
      arguments m_g vs g0;
      let st = statement sigma theta iota ((v, Prd m_ty) :: g1) s in
      MkTyped (gamma, Let (v, m, vs, st))
    
    | New (v, tty, vs, bs, s) ->
      let g0, g1 = skip vs gamma in
      let sgn = get_signature tty sigma in
      let cs = List.map2
        (fun (m1, g1) (m', vs', s1) ->
          symbols m1 m';
          arguments g1 vs' g0;
          let st1 = statement sigma theta iota (g0 @ g1) s1 in
          (m', vs', st1))
        sgn bs
      in
      let st = statement sigma theta iota ((v, Cns tty) :: g1) s in
      MkTyped (gamma, New (v, tty, vs, cs, st))
    
    | Switch (v, bs) ->
      (match gamma with
      | (v', Prd tty) :: g when v' = v ->
        let sgn = get_signature tty sigma in
        let cs = List.map2
          (fun (m1, g1) (m1', vs', s1) ->
            symbols m1 m1';
            arguments g1 vs' gamma;
            let st1 = statement sigma theta iota (g1 @ g) s1 in
            (m1', vs', st1))
          sgn bs
        in
        MkTyped (gamma, Switch (v, cs))
      | _ -> error "incorrect producer type")
    
    | Invoke (v, m) ->
      (match gamma with
      | (v', Cns tty) :: g when v' = v ->
        let sgn = get_signature tty sigma in
        (match List.assoc_opt m sgn with
        | Some m_g ->
          arguments m_g (List.map fst g) g;
          MkTyped (gamma, Invoke (v, m))
        | None -> error "unknown method in invoke")
      | _ -> error "incorrect consumer type")
    
    | Extern (m, vs, ss) ->
      let (ins, outs) = get_interface m iota in
      List.iter2
        (fun t v ->
          let v_ty = get_type v gamma in
          if t <> v_ty then error "argument type mismatch in extern")
        ins vs;
      let sts = List.map2
        (fun ts (ys, s1) ->
          let g1 = List.combine ys ts in
          let st1 = statement sigma theta iota (g1 @ gamma) s1 in
          (ys, st1))
        outs ss
      in
      MkTyped (gamma, Extern (m, vs, sts))
end

type definition =
  { name: label
  ; args: typ_env
  ; body: statement
  } 

type program =
  { imports: import_env
  ; signatures: signature_env
  ; definitions: definition list
  }

type typed_definition =
  { name: label
  ; args: typ_env
  ; body: typed_statement
  }

type typed_program =
  { imports: import_env
  ; signatures: signature_env
  ; definitions: typed_definition list
  }

let mk_typed (prog: program) =
  let labels =
    List.map
      (fun (def: definition) -> (def.name, def.args))
      prog.definitions
  in
  { imports = prog.imports;
    signatures = prog.signatures;
    definitions =
      List.map
        (fun (def: definition) ->
          let typed_body =
            Check.statement
              prog.signatures
              labels
              prog.imports
              def.args
              def.body
          in
          { name = def.name
          ; args = def.args
          ; body = typed_body
          })
        prog.definitions }
